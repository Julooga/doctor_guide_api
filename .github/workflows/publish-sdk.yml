name: Build and Publish SDK

on:
  workflow_dispatch: # 수동 실행 옵션
    inputs:
      package_name:
        description: '@julooga/doctor_guide_api_sdk'
        required: false
  # workflow_run:
  #   workflows: ['semantic-release']
  #   types:
  #     - completed
  #   branches:
  #     - main

permissions:
  contents: write
  packages: write

jobs:
  # 1. 전용 작업 공간에서 SDK 빌드
  build:
    name: Build SDK
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.extract-version.outputs.version }}
      package_scope: ${{ steps.generate-sdk.outputs.package_scope }}
      package_name: ${{ steps.generate-sdk.outputs.package_name }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 'latest'
          run_install: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm i --frozen-lockfile

      # 태그에서 버전 추출
      - name: Extract version from tag
        id: extract-version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            # 태그에서 버전 추출 (refs/tags/ 제거)
            TAG="${GITHUB_REF#refs/tags/}"
            # 'v' 접두사가 있으면 제거
            if [[ "$TAG" == v* ]]; then
              VERSION="${TAG#v}"
            else
              VERSION="$TAG"
            fi
          else
            # 태그가 없는 경우 package.json에서 버전 가져오기
            VERSION=$(node -p "require('./package.json').version")
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

      # 전용 작업 공간에서 SDK 빌드 (최적화된 방식)
      - name: Generate SDK in workspace
        run: |
          # SDK 생성
          pnpm build:api

          # 동적 변수 설정
          VERSION="${{ steps.extract-version.outputs.version }}"
          REPO_URL=$(node -p "require('./package.json').repository.url")

          # 저장소 이름에서 패키지 이름 추출 (GitHub URL에서 조직/저장소 형식 추출)
          REPO_FULL_NAME=$(echo $REPO_URL | sed -E 's|.*github.com[:/]([^/]+/[^/.]+).*|\1|')

          # 조직명을 소문자로 변환
          ORG_NAME=$(echo $REPO_FULL_NAME | cut -d '/' -f 1 | tr '[:upper:]' '[:lower:]')
          REPO_NAME=$(echo $REPO_FULL_NAME | cut -d '/' -f 2)

          # 기본 패키지 이름 (원본 package.json에서 가져옴)
          BASE_PACKAGE_NAME=$(node -p "require('./package.json').name")

          # 워크플로우 디스패치에서 패키지 이름이 제공되었는지 확인
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.package_name }}" != "" ]]; then
            # 워크플로우 디스패치에서 제공된 패키지 이름 사용
            PACKAGE_NAME="${{ github.event.inputs.package_name }}"
          else
            # 기본값: @조직명/저장소명_sdk (조직명은 소문자)
            PACKAGE_NAME="@${ORG_NAME}/${REPO_NAME}_sdk"
          fi

          # 패키지 설명 동적 생성
          PACKAGE_DESCRIPTION=$(node -p "require('./package.json').description || '${REPO_NAME} API SDK'")

          # 스코프 정보 저장 (다음 작업에서 사용)
          SCOPE=$(echo $PACKAGE_NAME | cut -d '/' -f 1)
          echo "package_scope=${SCOPE}" >> $GITHUB_OUTPUT
          echo "package_name=${PACKAGE_NAME}" >> $GITHUB_OUTPUT

          # package.json 동적 생성
          cat > ./workspace/package.json << EOF
          {
            "name": "${PACKAGE_NAME}",
            "version": "${VERSION}",
            "description": "${PACKAGE_DESCRIPTION}",
            "main": "api.ts",
            "types": "api.ts",
            "repository": {
              "type": "git",
              "url": "${REPO_URL}"
            },
            "author": "${ORG_NAME}",
            "license": "MIT",
            "dependencies": {
              "axios": "^1.9.0"
            }
          }
          EOF

          echo "SDK generated with name ${PACKAGE_NAME} and version ${VERSION}"
          echo "Package scope: ${SCOPE}"

      # 빌드 결과물을 아티팩트로 저장
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: sdk-build
          path: ./workspace

  # 2. 빌드 결과물을 dist 브랜치로 푸시
  deploy-to-dist:
    name: Deploy to dist branch
    needs: build
    runs-on: ubuntu-latest
    steps:
      # 기본 브랜치 체크아웃
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # 전체 히스토리 가져오기
          token: ${{ secrets.GITHUB_TOKEN }}

      # Git 사용자 설정
      - name: Configure Git
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

      # 빌드 아티팩트 다운로드
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: sdk-build
          path: ./sdk-artifacts

      # dist 브랜치 강제 재생성 (기존 브랜치 삭제 후 새로 생성)
      - name: Force recreate dist branch
        run: |
          # 로컬 브랜치 목록 확인
          echo "Current local branches:"
          git branch -a

          # 원격 dist 브랜치 존재 여부 확인
          if git ls-remote --heads origin dist | grep dist; then
            echo "Remote dist branch exists - will delete and recreate"
            
            # 원격 브랜치 강제 삭제 시도 (실패해도 계속 진행)
            git push origin --delete dist || echo "Failed to delete remote branch, continuing anyway"
            sleep 2  # 삭제 작업이 완료될 때까지 잠시 대기
          else
            echo "Remote dist branch does not exist - will create new"
          fi

          # 로컬에 dist 브랜치가 있으면 삭제
          git branch -D dist 2>/dev/null || echo "No local dist branch to delete"

          # 빈 dist 브랜치 새로 생성
          git checkout --orphan dist
          git reset --hard  # 작업 디렉토리 초기화

          # 아티팩트 파일 복사
          cp -r ./sdk-artifacts/* ./ || echo "No artifacts to copy"

          # 모든 파일 추가 및 커밋
          git add -A
          git commit -m "chore: update SDK to version ${{ needs.build.outputs.version }}" || echo "Nothing to commit"

          # 강제 푸시 (--force 플래그 사용)
          git push --force origin dist
          echo "Dist branch recreated successfully"

      # 태그 푸시 시 dist 브랜치에도 태그 생성
      - name: Create dist tag
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          VERSION="${{ needs.build.outputs.version }}"
          # 기존 태그가 있으면 삭제
          git push origin :refs/tags/dist-v${VERSION} 2>/dev/null || echo "No existing tag to delete"
          # 새 태그 생성 및 푸시
          git tag -f "dist-v${VERSION}"
          git push --force origin "dist-v${VERSION}"
          echo "Dist tag created successfully"

  # 3. dist 브랜치에서 GitHub Packages에 게시
  publish:
    name: Publish to GitHub Packages
    needs: [build, deploy-to-dist]
    runs-on: ubuntu-latest
    steps:
      # dist 브랜치 체크아웃
      - name: Checkout dist branch
        uses: actions/checkout@v4
        with:
          ref: dist

      # Node.js 및 npm 레지스트리 설정
      - name: Setup Node.js with registry
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://npm.pkg.github.com'
          scope: '${{ needs.build.outputs.package_scope }}'

      # GitHub Packages에 게시
      - name: Publish package
        run: |
          # 패키지 정보 출력 (디버깅용)
          echo "Publishing package: ${{ needs.build.outputs.package_name }}"
          echo "Using scope: ${{ needs.build.outputs.package_scope }}"

          # 동적 스코프로 .npmrc 설정
          echo "${{ needs.build.outputs.package_scope }}:registry=https://npm.pkg.github.com/" > .npmrc
          echo "//npm.pkg.github.com/:_authToken=${NODE_AUTH_TOKEN}" >> .npmrc

          # 설정 확인 (디버깅용)
          echo "NPM configuration:"
          cat .npmrc
          echo "Package.json content:"
          cat package.json

          # 패키지 게시
          npm publish --no-git-checks --access public
        env:
          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
